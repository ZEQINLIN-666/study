# 4.6

# HTTP

## 简述什么是HTTP?

HTTP协议全程叫超文本传输协议。是基于TCP的应用层协议。
http协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。

HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

HTTP是不保存状态的协议，既无状态协议，协议本身对于请求或响应之间的通信状态不进行保存，因此连接双方不能知晓对方当前的身份和状态。

这也是Cookie技术产生的重要原因之一：客户端的状态管理。浏览器会根据从服务器端发送的响应报文内 Set-Cookie 首部字段信息自动保持 Cookie。而每次客户端发送 HTTP 请求，都会在请求报文中携带 Cookie，作为服务端识别客户端身份状态的标识。

## Http的优缺点

**特点**：`无连接`、`无状态`、`灵活`、`简单快速`

- **无连接（短链接）**：每一次请求都要连接一次，请求结束就会断掉，不会保持连接
- **无状态**：每一次请求都是独立的，请求结束不会记录连接的任何信息(**提起裤子就不认人的意思**)，减少了网络开销，这`是优点也是缺点`
- **灵活**：通过http协议中头部的`Content-Type`标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活
- **简单快速**：发送请求访问某个资源时，只需传送请求方法和URL就可以了，使用简单，正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快

**缺点**：`无状态`、`不安全`、`明文传输`、`队头阻塞`

- **无状态**：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。（加购，下单，支付都需要验证身份）
- **不安全**：`明文传输`可能被窃听不安全，缺少`身份认证`也可能遭遇伪装，还有缺少`报文完整性验证`可能遭到篡改
- **明文传输**：报文(header部分)使用的是明文，直接将信息暴露给了外界，`WIFI陷阱`就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息
- **队头阻塞**：开启`长连接`(下面有讲)时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态

## HTTP请求方法

## HTTP 请求方法(9种)

**HTTP1.0：** `GET`、`POST`、`HEAD`

**HTTP1.1：** `PUT`、`PATCH`、`DELETE`、`OPTIONS`、`TRACE`、`CONNECT`

| 方法     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| **GET**  | 获取资源，GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回； |
| **POST** | `POST 传输实体`，虽然 GET 方法也可以传输主体信息，但是便于区分，我们一般不用 GET 传输实体信息，反而使用 POST 传输实体信息，通常会造成服务器资源的修改 |
| **HEAD** | HEAD 获得响应首部，HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。 |
| PUT      | PUT 传输文件，PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。<br/>但是，鉴于 HTTP 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 W eb 网站不使用该方法。若配合 W eb 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。 |
| PATCH    | 对PUT的补充，对已知资源部分更新                              |
| DELETE   | 删除资源。DELETE 删除文件，DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源 |
| OPTIONS  | 列出请求资源支持的请求方法，用来跨域请求                     |
| TRACE    | 追踪请求/响应路径，用于测试或诊断。TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。 |
| CONNECT  | CONNECT 要求用隧道协议连接代理，CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 `SSL（Secure Sockets Layer，安全套接层）`和 TLS`（Transport Layer Security，传输层安全）`协议把通信内容加 密后经网络隧道传输。 |

### GET 和 POST 的区别

- `GET`在浏览器回退时是无害的，而`POST`会再次发起请求
- `GET`请求会被浏览器主动缓存，而`POST`不会，除非手动设置
- `GET`请求参数会被保留在浏览器历史记录里，而`POST`中的参数不会被保留
- `GET`请求在`URL`中传递的参数有长度限制(浏览器限制大小不同)，而`POST`没有限制
- `GET`参数通过`URL`传递，`POST`放在`Request body`中
- `GET`产生的URL地址可以被收藏，而`POST`不可以
- `GET`没有`POST`安全，因为`GET`请求参数直接暴露在`URL`上，所以不能用来传递敏感信息
- `GET`请求只能进行`URL`编码，而`POST`支持多种编码方式
- 对参数的数据类型，`GET`只接受`ASCII`字符，而`POST`没有限制
- `GET`产生一个TCP数据包，`POST`产生两个数据包(Firefox只发一次)。GET浏览器把 http header和data一起发出去，响应成功200，POST先发送header，响应100 continue，再发送data，响应成功200

- GET ⽅法是安全且幂等的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是安全 的，且每次的结果都是相同的。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多 个资源，所以不是幂等的。

### HTTP的get方法如何判断数据传输完毕

- HTTP协议的服务端响应报文里有Content-Length字段，明确了报文的长度。客户端应该是通过这个来判断的。

### POST 有哪几种编码方式

- urlencoded

  ```http
  POST http://www.example.com HTTP/1.1
  Content-Type: application/x-www-form-urlencoded;charset=utf-8
  
  title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3
  ```

  Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。

- multipart/form-data

  这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 <form> 表单的 `enctype` 等于 multipart/form-data

- application/json

  用来告诉服务端消息主体是序列化后的 JSON 字符串

  ```http
  POST http://www.example.com HTTP/1.1 
  Content-Type: application/json;charset=utf-8
  
  {"title":"test","sub":[1,2,3]}
  ```

- text/xml

### 为什么post要分两次发送(大文件可以先验证文件信息)

Post请求发送一次还是两次，取决与浏览器自己的实现。

**比如上传文件的场景，请求头中有文件的名字等信息，请求体是文件本身，如果文件很大就可以分别发送，先验证请求头，文件名等信息是否符合要求，如果不符合就没有必要发送请求体了。**

另外Ajax是会分两次发送的，这是因为Ajax使用了XMLHttpRequest API，浏览器会先发送请求头吗，再发送请求体，但是火狐浏览器不会。
所以Post请求到底是发送一次还是两次，取决于浏览器的实现，不论一次还是两次都是符合标准的。



## HTTP 报文组成部分

**http报文**：由`请求报文`和`响应报文`组成

**请求报文**：由`请求行`、`请求头`、`空行`、`请求体`四部分组成

**响应报文**：由`状态行`、`响应头`、`空行`、`响应体`四部分组成

- **请求行**：包含http方法，请求地址，http协议以及版本
- **请求头/响应头**：就是一些key:value来告诉服务端我要哪些内容，要注意什么类型等，[请求头/响应头每一个字段详解](https://link.juejin.cn?target=https%3A%2F%2Fkb.cnblogs.com%2Fpage%2F92320%2F)
- **空行**：用来区分首部与实体，因为请求头都是key:value的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了
- **请求体**：请求的参数
- **状态行**：包含http协议及版本、数字状态码、状态码英文名称
- **响应体**：服务端返回的数据

```dart
GET         /s?wd=nihao  HTTP/2.0  —— 请求行（Request Line）
方法(method) 路径(Path)   HTTP版本(version)

Host: www.baidu.com      |
Content-Type: text/html  |   Headers（键值对）
Content-Length: 243      |

bodybodybodybodybody  —— Body(注意Get请求方式是没有Body的，这里只是举例说明。所以Get的参数只要放入路径Path中就好)
```

![img](https://upload-images.jianshu.io/upload_images/8654767-0254ee6430baf17f.png?imageMogr2/auto-orient/strip|imageView2/2/w/600/format/webp)

### Http header(头)的内容

#### Requests部分

|     Header      |                             解释                             |                       示例                        |
| :-------------: | :----------------------------------------------------------: | :-----------------------------------------------: |
|     Accept      |                 指定客户端能够接收的内容类型                 |           Accept: text/plain, text/html           |
| Accept-Charset  |                 浏览器可以接受的字符编码集。                 |            Accept-Charset: iso-8859-5             |
| Accept-Encoding |     指定浏览器可以支持的web服务器返回内容压缩编码类型。      |          Accept-Encoding: compress, gzip          |
| Accept-Language |                      浏览器可接受的语言                      |              Accept-Language: en,zh               |
|  Authorization  |                      HTTP授权的授权证书                      | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== |
|  Cache-Control  |                 指定请求和响应遵循的缓存机制                 |              Cache-Control: no-cache              |
|   Connection    |      表示是否需要持久连接。（HTTP 1.1默认进行持久连接）      |                 Connection: close                 |
|     Cookie      | HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 |           Cookie: $Version=1; Skin=new;           |
| Content-Length  |                        请求的内容长度                        |                Content-Length: 348                |
|  Content-Type   |              告诉服务端本次请求的数据是什么格式              |  Content-Type: application/x-www-form-urlencoded  |
|      Date       |                     请求发送的日期和时间                     |        Date: Tue, 15 Nov 2010 08:12:31 GMT        |
|      Host       |                指定请求的服务器的域名和端口号                |                Host: www.zcmhi.com                |
|   User-Agent    |                    包含发出请求的用户信息                    |       User-Agent: Mozilla/5.0 (Linux; X11)        |

#### Responses 部分

|      Header      |                   解释                   |                  示例                  |
| :--------------: | :--------------------------------------: | :------------------------------------: |
|  Cache-Control   | 告诉所有的缓存机制是否可以缓存及哪种类型 |        Cache-Control: no-cache         |
| Content-Encoding |  web服务器支持的返回内容压缩编码类型。   |         Content-Encoding: gzip         |
| Content-Language |               响应体的语言               |        Content-Language: en,zh         |
|  Content-Length  |               响应体的长度               |          Content-Length: 348           |
|   Content-Type   |            返回内容的MIME类型            | Content-Type: text/html; charset=utf-8 |

### Http中的content-type有哪些

MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。

 例如： Content-Type: text/html;charset:utf-8;

 一、常见的媒体格式类型如下：

-   text/html ： HTML格式
-   text/plain ：纯文本格式   
-   text/xml ： XML格式
-   image/gif ：gif图片格式  
-   image/jpeg ：jpg图片格式 
-   image/png：png图片格式

  二、以application开头的媒体格式类型：

-   application/xhtml+xml ：XHTML格式
-   application/xml   ： XML数据格式
-   application/atom+xml ：Atom XML聚合格式  
-   application/json  ： JSON数据格式
-   application/pdf    ：pdf格式 
-   application/msword ： Word文档格式
-   application/octet-stream ： 二进制流数据（如常见的文件下载）
-   application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）

  三、另外一种常见的媒体格式是上传文件之时使用的：

-   multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式

   以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。



### 状态码

> ### 100 Continue
>
> 表示目前为止一切正常, 客户端应该继续请求, 如果已完成请求则忽略.
>
> 为了让服务器检查请求的首部, 客户端必须在发送请求实体前, 在初始化请求中发送 Expect: 100-continue 首部并接收 100 Continue 响应状态码.
>
> #### Expect
>
> 包含一个期望条件，表示服务器只有在满足此期望条件的情况下才能妥善地处理请求。
>
> 规范中只规定了一个期望条件，即 Expect: 100-continue, 对此服务器可以做出如下回应：
>
> - 100 如果消息头中的期望条件可以得到满足，使得请求可以顺利进行的话，
> - 417 (Expectation Failed) 如果服务器不能满足期望条件的话；也可以是其他任意表示客户端错误的状态码（4xx）。
>
> 
>
> ### 200 OK
>
> 表明请求已经成功. 默认情况下状态码为200的响应可以被缓存。
>
> ### 204 No Content
>
> 表示目前请求成功，但客户端不需要更新其现有页面。
>
> 使用惯例是，在 PUT 请求中进行资源更新，但是不需要改变当前展示给用户的页面，那么返回 204 No Content。如果新创建了资源，那么返回 201 Created 。如果页面需要更新以反映更新后的资源，那么需要返回 200 。
>
> 
>
> ### 301 Moved Permanently
>
> 永久重定向。说明请求的资源已经被移动到了由 Location 头部指定的 url 上，是固定的不会再改变。搜索引擎会根据该响应修正。
>
> ### 308 Permanent Redirect
>
> 永久重定向。类似 301，区别在于能够确保请求方法和消息主体不会发生改变。
>
> > 尽管标准要求浏览器在收到该响应并进行重定向时不应该修改 http method 和 body，但是有一些浏览器可能会有问题。
> >
> > 所以最好是在应对 GET 或 HEAD 方法时使用 301，其他情况使用 308 来替代 301
>
> 
>
> ### 302 Found
>
> 临时重定向。重定向状态码表明请求的资源被暂时的移动到了由 Location 头部指定的 URL 上。浏览器会重定向到这个URL，但是搜索引擎不会对该资源的链接进行更新。
>
> ### 307 Temporary Redirect
>
> 临时重定向。类似 302，区别在于能够确保请求方法和消息主体不会发生改变。
>
> - 即使规范要求浏览器在重定向时保证请求方法和请求主体不变，但并不是所有的用户代理都会遵循这一点，你依然可以看到有缺陷的软件的存在。所以推荐仅在响应 GET 或 HEAD 方法时采用 302 状态码，而在其他时候使用 307  来替代，因为在这些场景下方法变换是明确禁止的。
> - 在确实需要将重定向请求的方法转换为 GET 的场景下，可以使用 303。例如在使用 PUT 方法进行文件上传操作时，需要返回确认信息（例如“你已经成功上传了xyz”）而不是上传的资源本身，就可以使用这个状态码。
>
> ### 303 See Other
>
> 通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。
>
> ### 304 Not Modified
>
> 说明无需再次传输请求的内容，也就是说可以使用缓存的内容。这通常是在一些安全的方法（safe），例如GET 或HEAD, 或在请求中附带了头部信息： If-None-Match 或If-Modified-Since。
>
> 如果返回 200，响应会带有头部 Cache-Control, Content-Location, Date, ETag, Expires，和 Vary.
>
> #### Last-Modified 和 If-Modified-Since
>
> 1. 客户端请求一个文件（A）。 服务器返回文件A，并返回 Last-Modified。
> 2. 客户端收到响应后，缓存文件A 和 Last-Modified。
> 3. 客户端再次请求文件A 时，发现该文件有 Last-Modified ，那么 header 离包含 If-Modified-Since，这个时间就是缓存文件的 Last-Modified。
> 4. 服务端收到请求，只需要判断这个时间和当前请求的文件的修改时间就可以确定是返回 304 还是 200
>
> If-Modified-Since 的主要缺点是只能精确到秒的级别，一旦在一秒内出现多次修改，是无法判断出已修改的状态。所以一般用在对时间不太敏感的静态资源。
>
> #### ETag 和 If-None-Match
>
> 1. 客户端请求一个文件（A）。 服务器返回文件A，并在给A加上一个 ETag。
> 2. 客户端收到响应后，并将文件连同 ETag 一起缓存。
> 3. 客户再次请求文件A，会发送 If-None-Match，内容是缓存该文件A的 Etag 值
> 4. 服务器检查该 ETag，和计算出来的 Etag 匹配，来判断文件是否未被修改。如果未修改就直接返回 304 和一个空的响应体。否则返回 200 和 文件。
>
> 当与  If-Modified-Since  一同使用的时候，If-None-Match 优先级更高（假如服务器支持的话）
>
> 
>
> ### 400 Bad Request
>
> 表示由于语法无效，服务器无法理解该请求。客户端不应该在未经修改的情况下重复此请求。
>
> ### 401 Unauthorized
>
> 说明由于缺乏目标资源要求的身份验证凭证，发送的请求未得到满足。
>
> 这个状态码会与 WWW-Authenticate 首部一起发送，其中包含有如何进行验证的信息。
>
> ### 403 Forbidden
>
> 指的是服务器端有能力处理该请求，但是拒绝授权访问。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关（例如不正确的密码）
>
> ### 404 Not Found
>
> 说明服务器端无法找到所请求的资源。返回该响应的链接通常称为坏链（broken link）或死链（dead link），它们会导向链接出错处理
>
> 404 不能说明请求的资源是临时还是永久丢失。如果服务器知道该资源是永久丢失，那么应该返回 410 (Gone) 而不是 404 。
>
> ### 410 Gone
>
> 说明请求的内容在服务器上不存在了，同时是永久性的丢失。如果不清楚是否为永久或临时的丢失，应该使用404。
>
> ### 405 Method Not Allowed
>
> 表明服务器禁止了使用当前 HTTP 方法的请求。需要注意的是，GET 与 HEAD 两个方法不得被禁止，当然也不得返回状态码 405。
>
> ### 406 Not Acceptable
>
> 表示服务器端不支持 Accept、Accept-Charset、Accept-Encoding、 Accept-Language header 所要求的。
>
> > #### Accept 和 Content-Type
> >
> > Accept 用来告知服务端。客户端可以处理的内容类型，这种内容类型用 [MIME](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FMIME_types) 类型来表示。服务器从中选择一项进行应用，并使用 Content-Type 应答头通知客户端。
> >
> > ```
> > Accept: <MIME_type>/<MIME_subtype>
> > Accept: <MIME_type>/*
> > Accept: */*
> > 
> > // Multiple types, weighted with the quality value syntax:
> > Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
> > 复制代码
> > ```
> >
> > - <MIME_type>/<MIME_subtype> : A single, precise MIME type, like text/html.
> > - <MIME_type>/* :  A MIME type, but without any subtype. image/* will match image/png, image/svg, image/gif and any other image types.
> > - */* : Any MIME type
> > - ;q= (q-factor weighting)
> >
> > #### Accept-Encoding 和 Content-Encoding
> >
> > Accept-Encoding 会将客户端能够理解的内容编码方式——通常是某种压缩算法——进行通知。服务端会从中选择一个使用，并在响应报文首部 Content-Encoding 中通知客户端。
> >
> > ```
> > Accept-Encoding: deflate, gzip;q=1.0, *;q=0.5
> > 
> > Content-Encoding: gzip
> > ```
>
> 
>
> ### 409 Conflict（版本冲突）
>
> 表示请求与服务器端目标资源的当前状态相冲突。
>
> 冲突最有可能发生在对 PUT 请求的响应中。例如，当上传文件的版本比服务器上已存在的要旧，从而导致版本冲突的时候，那么就有可能收到状态码为 409 的响应。
>
> 
>
> ### 500 Internal Server Error
>
> 表示所请求的服务器遇到意外的情况并阻止其执行请求。
>
> 举例：代码语法错误；php代码运行内存超了内存限制 memory_limit；nginx config 配置错误；
>
> ### 502 Bad Gateway
>
> 表示作为网关或代理角色的服务器Nginx，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的。
>
> 举例： tomcat 挂掉了，后端服务器tomcat没有起来，应用服务的问题
>
> ### 503 Service Unavailable
>
> 表示服务器尚未处于可以接受请求的状态。通常造成这种情况的原因是由于服务器停机维护或者已超载。该种响应应该用于临时状况下，与之同时，在可行的情况下，应该在 Retry-After 首部字段中包含服务恢复的预期时间。
>
> 举例：服务器停机维护时，主动用503响应请求；nginx 设置限速之类的，超过限速，会返回503。
>
> 
>
> >#### Retry-After
> >
> >表示用户代理需要等待多长时间之后才能继续发送请求。
> >
> >```http
> >Retry-After: Wed, 21 Oct 2015 07:28:00 GMT
> >Retry-After: 120
> >```
>
> 
>
> ### 504 Gateway Timeout
>
> 表示网关或者代理的服务器无法在规定的时间内获得想要的响应。
>
> 举例：代码执行时间超时，或死循环了。

#### 301和302的区别

> ### 在应用方面：
>
> #### 301适合永久重定向
>
> 301比较常用的场景是使用域名跳转。
>
> 比如，我们访问 **http**://www.baidu.com 会跳转到 **https**://www.baidu.com，发送请求之后，就会返回301状态码，然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。 
>
> **注意： 301请求是可以缓存的， 即通过看status code，可以发现后面写着from cache。**
>
>  **或者你把你的网页的名称从php修改为了html，这个过程中，也会发生永久重定向。**
>
> #### **302用来做临时跳转**
>
> 比如未登陆的用户访问用户中心重定向到登录页面。
>
> 访问404页面会重新定向到首页。 
>
> ## 在搜索引擎的角度
>
> 　　302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，**因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。**
>
> 　　**而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。**



## HTTP的演化

#### **一、HTTP1.0:**

- 短连接，每次请求都要创建连接
- 请求-响应模型，上一个请求得到响应之后才能继续发送请求。

#### **二、HTTP1.1:**

> ### HTTP/1.1 相⽐ HTTP/1.0 提⾼了什么性能？
>
> HTTP/1.1 相⽐ HTTP/1.0 性能上的改进：（长连接+管道） 
>
> 一、使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接（每一个请求，都会建立连接）造成的性能开销。在HTTP1.1中默认开启Connection： keep-alive 
>
> 二、⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间
>
> ### HTTP/1.1 的性能瓶颈：
>
> 1. 请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 消息体Body 的部分； 
> 2. 发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多； 
> 3. 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞； 
> 4. 没有请求优先级控制； 
> 5. 请求只能从客户端开始，服务器只能被动响应
>
> ### http1.1 为什么无法做到多路复用
>
> **HTTP/2是基于二进制“帧”的协议，HTTP/1.1是基于“文本分割”解析的协议。**
>
> HTTP/1.1发送请求消息的文本格式：以换行符分割每一条key:value的内容，“服务端”需要不断的读入字节，直到遇到分隔符（这里指换行符，代码中可能使用/n或者/r/n表示），这种解析方式是可行的，并且HTTP/1.1已经被广泛使用了二十多年，这事已经做过无数次了，问题一直都是存在的：
>
> - 一次只能处理一个请求或响应，因为这种以分隔符分割消息的数据，在完成之前不能停止解析。
> - 解析这种数据无法预知需要多少内存，这会带给“服务端”很大的压力，因为它不知道要把一行要解析的内容读到多大的“缓冲区”中，在保证解析效率和速度的前提下：内存该如何分配？

#### 三、HTTP2

> ### 针对HTTP/1.1 的性能瓶颈， HTTP/2 做了什么优化？
>
> HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。 
>
> 1. **头部压缩** HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分。 
>
>    这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。 
>
> 2. **⼆进制格式** HTTP/2 不再像 HTTP/1.1 ⾥的纯⽂本形式的报⽂，⽽是全⾯采⽤了⼆进制格式，头信息和数据体都是⼆进制，并且统称为帧（frame）： 头信息帧和数据帧。服务端在收到报⽂后，⽆需再将明⽂的报⽂转成⼆进制，⽽是直接解析⼆进制报⽂，这增加了数据传输的效率 
>
>    ![图片描述](https://image-static.segmentfault.com/264/608/2646086523-5be7a579c6b6e_articlex)
>
>    帧的字节中保存了不同的信息，前9个字节对于每个帧都是一致的，“服务器”解析HTTP/2的数据帧时只需要解析这些字节，就能准确的知道整个帧期望多少字节数来进行处理信息
>
> 3. **数据流** HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。 
>
>    ![图片描述](https://image-static.segmentfault.com/649/701/649701929-5be7b76c29006_articlex)
>
>    每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数
>
>    客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求。 
>
> 4. **多路复⽤** HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。 移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题， 降低了延迟，⼤幅度提⾼了连接的利⽤率 
>
>    举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分 
>
> 5. **服务器推送** HTTP/2 还在⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务不再是被动地响应，也可以主动向客户端发送消息。 举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、 CSS ⽂件等静态资源主动发给客户端， 减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）

#### 四、HTTP3

> ### http3.0解决了http2.0的什么问题
>
> HTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。 
>
> HTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了。 HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。 
>
>  这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！ UDP 发⽣是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的⼀个丢包全部重传问 题



## 长连接与短连接的区别

HTTP分为长连接和短连接，其实本质上是说的TCP连接。TCP连接是一个双向的通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说。

长连接是为了复用，多个HTTP请求可以复用同一个TCP连接，这就节省了很多TCP连接建立和断开的消耗。

比如你请求了一个网页，这个网页里肯定还包含了CSS、JS等等一系列资源，如果你是短连接（也就是每次都要重新建立TCP连接）的话，那你每打开一个网页，基本要建立几个甚至几十个TCP连接，这浪费了多少资源。

但如果是长连接的话，那么这么多次HTTP请求（这些请求包括请求网页内容，CSS文件，JS文件，图片等等），其实使用的都是一个TCP连接，很显然是可以节省很多消耗的。

注意：长连接并不是永久连接的。如果一段时间内（具体的时间长短，是可以在header当中进行设置的，也就是所谓的超时时间），这个连接没有HTTP请求发出的话，那么这个长连接就会被断掉。



http缓存（强缓存和协商缓存）
Http缓存定义与原理
立足于http协议解释，为何第二次从网页上下载图片会变快
下载文件时下载速度为什么会先上升再平滑？
如何断点续传？

Http与Tcp的关系与区别
keep-alive在http和tcp/ip中的区别
Http与Rpc的关系
http请求中的跨域问题
为什么代理之后就不存在跨域问题了？
代理服务器和服务器之间存在跨域问题吗？
把allow-origin设置为*会有什么问题？
Http如何保证安全传输
Http建立连接的过程
简述HTTP的工作机制
http断点续传的实现机制
Cache-Concrol和expire的区别
no-cache 和 no-store 的区别
请求页面的资源分布在不同服务器， 需要建立几次Http和TCP连接？
Http可以长连接，但为何还是无状态？
Http的无状态具体指的是什么
Cookie中包含哪些内容
域名相同，协议不同，cookie是否可以传递？
HTTP无状态，如何标注用户身份

Http、Https、两者区别
Http、Https 性能比较
Http与Https的端口号

介绍Https中间安全层
Https的加密流程
Https加密算法用在哪个步骤？
Https建立连接时服务器返回的证书的内容
为什么https要采用混合加密算法
SSL如何加密
ssl协议属于哪一层
Https的TLS的工作原理
https如何保证可靠性
HTTPS怎么保证数据安全
Https为什么安全？
非对称密钥算法
https建立连接的过程
如何验证CA证书的可靠性
简述CA证书
Https如何断定恶意网址
如果晚上0点有大量请求，如何区分恶意与善意请求？
如何改善https构建请求速度慢的情况