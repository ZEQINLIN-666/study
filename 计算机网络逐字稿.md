# 4.6

# HTTP

## 简述什么是HTTP?

HTTP协议全程叫超文本传输协议。是基于TCP的应用层协议。
http协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。

HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

HTTP是不保存状态的协议，既无状态协议，协议本身对于请求或响应之间的通信状态不进行保存，因此连接双方不能知晓对方当前的身份和状态。

这也是Cookie技术产生的重要原因之一：客户端的状态管理。浏览器会根据从服务器端发送的响应报文内 Set-Cookie 首部字段信息自动保持 Cookie。而每次客户端发送 HTTP 请求，都会在请求报文中携带 Cookie，作为服务端识别客户端身份状态的标识。

## Http的优缺点

**特点**：`无连接`、`无状态`、`灵活`、`简单快速`

- **无连接（短链接）**：每一次请求都要连接一次，请求结束就会断掉，不会保持连接
- **无状态**：每一次请求都是独立的，请求结束不会记录连接的任何信息(**提起裤子就不认人的意思**)，减少了网络开销，这`是优点也是缺点`
- **灵活**：通过http协议中头部的`Content-Type`标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活
- **简单快速**：发送请求访问某个资源时，只需传送请求方法和URL就可以了，使用简单，正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快

**缺点**：`无状态`、`不安全`、`明文传输`、`队头阻塞`

- **无状态**：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。（加购，下单，支付都需要验证身份）
- **不安全**：`明文传输`可能被窃听不安全，缺少`身份认证`也可能遭遇伪装，还有缺少`报文完整性验证`可能遭到篡改
- **明文传输**：报文(header部分)使用的是明文，直接将信息暴露给了外界，`WIFI陷阱`就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息
- **队头阻塞**：开启`长连接`(下面有讲)时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态

## HTTP请求方法

## HTTP 请求方法(9种)

**HTTP1.0：** `GET`、`POST`、`HEAD`

**HTTP1.1：** `PUT`、`PATCH`、`DELETE`、`OPTIONS`、`TRACE`、`CONNECT`

| 方法     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| **GET**  | 获取资源，GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回； |
| **POST** | `POST 传输实体`，虽然 GET 方法也可以传输主体信息，但是便于区分，我们一般不用 GET 传输实体信息，反而使用 POST 传输实体信息，通常会造成服务器资源的修改 |
| **HEAD** | HEAD 获得响应首部，HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。 |
| PUT      | PUT 传输文件，PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。<br/>但是，鉴于 HTTP 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 W eb 网站不使用该方法。若配合 W eb 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。 |
| PATCH    | 对PUT的补充，对已知资源部分更新                              |
| DELETE   | 删除资源。DELETE 删除文件，DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源 |
| OPTIONS  | 列出请求资源支持的请求方法，用来跨域请求                     |
| TRACE    | 追踪请求/响应路径，用于测试或诊断。TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。 |
| CONNECT  | CONNECT 要求用隧道协议连接代理，CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 `SSL（Secure Sockets Layer，安全套接层）`和 TLS`（Transport Layer Security，传输层安全）`协议把通信内容加 密后经网络隧道传输。 |

### GET 和 POST 的区别

- `GET`在浏览器回退时是无害的，而`POST`会再次发起请求
- `GET`请求会被浏览器主动缓存，而`POST`不会，除非手动设置
- `GET`请求参数会被保留在浏览器历史记录里，而`POST`中的参数不会被保留
- `GET`请求在`URL`中传递的参数有长度限制(浏览器限制大小不同)，而`POST`没有限制
- `GET`参数通过`URL`传递，`POST`放在`Request body`中
- `GET`产生的URL地址可以被收藏，而`POST`不可以
- `GET`没有`POST`安全，因为`GET`请求参数直接暴露在`URL`上，所以不能用来传递敏感信息
- `GET`请求只能进行`URL`编码，而`POST`支持多种编码方式
- 对参数的数据类型，`GET`只接受`ASCII`字符，而`POST`没有限制
- `GET`产生一个TCP数据包，`POST`产生两个数据包(Firefox只发一次)。GET浏览器把 http header和data一起发出去，响应成功200，POST先发送header，响应100 continue，再发送data，响应成功200

- GET ⽅法是安全且幂等的，因为它是「只读」操作，⽆论操作多少次，服务器上的数据都是安全 的，且每次的结果都是相同的。 POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多 个资源，所以不是幂等的。

### HTTP的get方法如何判断数据传输完毕

- HTTP协议的服务端响应报文里有Content-Length字段，明确了报文的长度。客户端应该是通过这个来判断的。

### POST 有哪几种编码方式

- urlencoded

  ```http
  POST http://www.example.com HTTP/1.1
  Content-Type: application/x-www-form-urlencoded;charset=utf-8
  
  title=test&sub%5B%5D=1&sub%5B%5D=2&sub%5B%5D=3
  ```

  Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。

- multipart/form-data

  这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 <form> 表单的 `enctype` 等于 multipart/form-data

- application/json

  用来告诉服务端消息主体是序列化后的 JSON 字符串

  ```http
  POST http://www.example.com HTTP/1.1 
  Content-Type: application/json;charset=utf-8
  
  {"title":"test","sub":[1,2,3]}
  ```

- text/xml

### 为什么post要分两次发送(大文件可以先验证文件信息)

Post请求发送一次还是两次，取决与浏览器自己的实现。

**比如上传文件的场景，请求头中有文件的名字等信息，请求体是文件本身，如果文件很大就可以分别发送，先验证请求头，文件名等信息是否符合要求，如果不符合就没有必要发送请求体了。**

另外Ajax是会分两次发送的，这是因为Ajax使用了XMLHttpRequest API，浏览器会先发送请求头吗，再发送请求体，但是火狐浏览器不会。
所以Post请求到底是发送一次还是两次，取决于浏览器的实现，不论一次还是两次都是符合标准的。





> Web服务器是如何解析HTTP请求报文
> 
> 

## HTTP 报文组成部分

**http报文**：由`请求报文`和`响应报文`组成

**请求报文**：由`请求行`、`请求头`、`空行`、`请求体`四部分组成

**响应报文**：由`状态行`、`响应头`、`空行`、`响应体`四部分组成

- **请求行**：包含http方法，请求地址，http协议以及版本
- **请求头/响应头**：就是一些key:value来告诉服务端我要哪些内容，要注意什么类型等，[请求头/响应头每一个字段详解](https://link.juejin.cn?target=https%3A%2F%2Fkb.cnblogs.com%2Fpage%2F92320%2F)
- **空行**：用来区分首部与实体，因为请求头都是key:value的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了
- **请求体**：请求的参数
- **状态行**：包含http协议及版本、数字状态码、状态码英文名称
- **响应体**：服务端返回的数据

### Http header(头)的内容

#### Requests部分

|     Header      |                             解释                             |                       示例                        |
| :-------------: | :----------------------------------------------------------: | :-----------------------------------------------: |
|     Accept      |                 指定客户端能够接收的内容类型                 |           Accept: text/plain, text/html           |
| Accept-Charset  |                 浏览器可以接受的字符编码集。                 |            Accept-Charset: iso-8859-5             |
| Accept-Encoding |     指定浏览器可以支持的web服务器返回内容压缩编码类型。      |          Accept-Encoding: compress, gzip          |
| Accept-Language |                      浏览器可接受的语言                      |              Accept-Language: en,zh               |
|  Authorization  |                      HTTP授权的授权证书                      | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== |
|  Cache-Control  |                 指定请求和响应遵循的缓存机制                 |              Cache-Control: no-cache              |
|   Connection    |      表示是否需要持久连接。（HTTP 1.1默认进行持久连接）      |                 Connection: close                 |
|     Cookie      | HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 |           Cookie: $Version=1; Skin=new;           |
| Content-Length  |                        请求的内容长度                        |                Content-Length: 348                |
|  Content-Type   |              告诉服务端本次请求的数据是什么格式              |  Content-Type: application/x-www-form-urlencoded  |
|      Date       |                     请求发送的日期和时间                     |        Date: Tue, 15 Nov 2010 08:12:31 GMT        |
|      Host       |                指定请求的服务器的域名和端口号                |                Host: www.zcmhi.com                |
|   User-Agent    |                    包含发出请求的用户信息                    |       User-Agent: Mozilla/5.0 (Linux; X11)        |

#### Responses 部分

|      Header      |                   解释                   |                  示例                  |
| :--------------: | :--------------------------------------: | :------------------------------------: |
|  Cache-Control   | 告诉所有的缓存机制是否可以缓存及哪种类型 |        Cache-Control: no-cache         |
| Content-Encoding |  web服务器支持的返回内容压缩编码类型。   |         Content-Encoding: gzip         |
| Content-Language |               响应体的语言               |        Content-Language: en,zh         |
|  Content-Length  |               响应体的长度               |          Content-Length: 348           |
|   Content-Type   |            返回内容的MIME类型            | Content-Type: text/html; charset=utf-8 |

### Http中的content-type有哪些

MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。

 例如： Content-Type: text/html;charset:utf-8;

 一、常见的媒体格式类型如下：

-   text/html ： HTML格式
-   text/plain ：纯文本格式   
-   text/xml ： XML格式
-   image/gif ：gif图片格式  
-   image/jpeg ：jpg图片格式 
-   image/png：png图片格式

  二、以application开头的媒体格式类型：

-   application/xhtml+xml ：XHTML格式
-   application/xml   ： XML数据格式
-   application/atom+xml ：Atom XML聚合格式  
-   application/json  ： JSON数据格式
-   application/pdf    ：pdf格式 
-   application/msword ： Word文档格式
-   application/octet-stream ： 二进制流数据（如常见的文件下载）
-   application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）

  三、另外一种常见的媒体格式是上传文件之时使用的：

-   multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式

   以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。









Http2.0、Http1.1、Http1.0有哪些特性

http3.0解决了http2.0的什么问题
Http2.0 二进制分帧改进
http2.0引入多路复用的目的
http1.1 为什么无法做到多路复用
Http1.1线头阻塞问题
长连接与短连接的区别
如何判断并开启Http长连接
http缓存（强缓存和协商缓存）
Http缓存定义与原理
立足于http协议解释，为何第二次从网页上下载图片会变快
下载文件时下载速度为什么会先上升再平滑？
如何断点续传？
Http响应状态码
Http状态码301与302的区别
Http重定向的返回状态码
Http与Tcp的关系与区别
keep-alive在http和tcp/ip中的区别
Http与Rpc的关系
http请求中的跨域问题
为什么代理之后就不存在跨域问题了？
代理服务器和服务器之间存在跨域问题吗？
把allow-origin设置为*会有什么问题？
Http如何保证安全传输
Http建立连接的过程
简述HTTP的工作机制
http断点续传的实现机制
Cache-Concrol和expire的区别
no-cache 和 no-store 的区别
请求页面的资源分布在不同服务器， 需要建立几次Http和TCP连接？
Http可以长连接，但为何还是无状态？
Http的无状态具体指的是什么
Cookie中包含哪些内容
域名相同，协议不同，cookie是否可以传递？
HTTP无状态，如何标注用户身份

Http、Https、两者区别
Http、Https 性能比较
Http与Https的端口号

介绍Https中间安全层
Https的加密流程
Https加密算法用在哪个步骤？
Https建立连接时服务器返回的证书的内容
为什么https要采用混合加密算法
SSL如何加密
ssl协议属于哪一层
Https的TLS的工作原理
https如何保证可靠性
HTTPS怎么保证数据安全
Https为什么安全？
非对称密钥算法
https建立连接的过程
如何验证CA证书的可靠性
简述CA证书
Https如何断定恶意网址
如果晚上0点有大量请求，如何区分恶意与善意请求？
如何改善https构建请求速度慢的情况